#!/usr/bin/env bash
#
#   vim:ft=sh:fenc=UTF-8:ts=4:sts=4:sw=4:expandtab:foldmethod=marker:foldlevel=0:
#
#   $Id: dvd2mkv 789 2008-03-24 13:02:06Z wael $
#
#   Copyright (c) 2007 Wael Nasreddine <wael.nasreddine@gmail.com>
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
#   USA.
#

# Bootstrap{{{
bootstrap="`dirname $0`/.bootstrap"
if [ -f "${bootstrap}" ]; then
    source "${bootstrap}"
else
    echo "Cannot bootstrap"
    exit 54
fi
unset bootstrap
#}}}

####
# Functions

function debug()
{
    if isTrue "${DEBUG}"; then
        return 0
    else
        return 1
    fi
}

function log()
{
    echo >> "${LOG}"
    echo "----------------------------------------------" >> "${LOG}"
    echo >> "${LOG}"
    echo "${@}" >> "${LOG}"
}

function scan_return_code()
{
    if [ "${1}" -ne "0" ]; then
        print_error 0 "The above operation returned with the exit status ${1}"
        print_warning 2 "You can review the output of the above command in the log file ${LOG}"
        print_error 2 "Aborting..."
        exit_script ${1}
    fi
}

function exit_script()
{
    cd "${OLDPWD}"
    exit ${1}
}

function die()
{
    print_error 0 "${@}"
    exit_script 1
}

function make_16()
{
    local m="${1}"

    while [ "$(expr $m % 16)" -ne 0 ]; do
        (( m -= 1 ))
    done
    echo ${m}
}

function welcome()
{
    clear

    #######################################
    #### TO REMOVE WHEN SCRIPT IS DONE ####
    #######################################
    print_warning 0 "${FG_YELLOW_B}WARNING${FG_WHITE_B}: The script is far from finished, Please do not use it\!"
    #######################################
    ####         END TO REMOVE         ####
    #######################################

    print_info 0 "Welcome to dvd2mkv, a bash script written by Wael Nasreddine <wael.nasreddine@gmail.com>"
    print_info 2 "The script is designed for DVD ripping, using x264 or xvid formats"
    print_info 2 "The output format is a Matroska movie, VLC or mplayer are good for Matroska playing."
    print_info 31 "http://wael.nasreddine.com"
}

function configure()
{
    local dvd_device dvd_mount_point temp_folder answer

    # Let's welcome our user
    welcome
    echo

    print_info 0 "It seems that you haven't configured your dvd2mkv yet, It's time to do that"
    print_info 1 "You will be asked some questions, please answer them and finish by enter."
    echo
    print_info 2 "What is your DVD drive device? : " false
    read dvd_device
    while [ ! -b "${dvd_device}" ]; do
        print_error 3 "The device ${FG_GREEN}${dvd_device}${FG_CLEAR} is either invalid or inexistant."
        print_info 2 "What is your DVD drive device? : " false
        read dvd_device
    done
    print_info 2 "What is your dvd mount point : " false
    read dvd_mount_point
    while [ ! -d "${dvd_mount_point}" ]; do
        print_error 3 "The mount point ${FG_GREEN}${dvd_mount_point}${FG_CLEAR} is either invalid or inexistant."
        print_info 2 "What is your dvd mount point : " false
        read dvd_mount_point
    done
    print_info 2 "Where do you want dvd2mkv to put the temporary files? (You need at lease 10Gb space) : " false
    read temp_folder
    if [ ! -d "${temp_folder}" ]; then
        print_info 3 "The folder ${FG_GREEN}${temp_folder}${FG_CLEAR} does not exist, Create it [y/n] : " false
        read -sn 1 answer; echo
        if isTrue "${answer}"; then
            print_info 4 "Creating folder ${FG_GREEN}${temp_folder}${FG_CLEAR}... " false
            mkdir -p "${temp_folder}"
            print_info 0 "Done" true false
        fi
    fi
    cat > "${HOME}/.dvd2mkvrc" << EOF
# This is the configuration file for dvd2mkv.

# DVD Device
DVD_DEVICE="${dvd_device}"

# DVD Mount Point
DVD_MOUNT_POINT="${dvd_mount_point}"

# Temporary Folder
TEMP="${temp_folder}"

# Keep ripped files?
# If set to true then none of the ripped files will be deleted
# it's usefull in case you made a mistake and you don't want to re-encode everything
KEEP_RIPED_FILES="true"

# Image Viewer
IMAGE_VIEWER="/usr/bin/feh"

###
# For help on video codec, and video codec options, please take a look at
# http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-xvid.html
# http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-x264.html
# http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-vcd-dvd.html#menc-feat-vcd-dvd-lavc-options
###

# Default Video ripping codec
VIDEO_CODEC="x264"

# Default Video Bitrate
VIDEO_BITRATE="800"

# Default Video Filter options
# Do not include CROP!
VF_OPTIONS=""

# Default number of passes to process video encoding
# Must be 1 or 2!
VIDEO_PASS="2"

# Default Video codec options
# Do not include pass=# !
VIDEO_CODEC_PASS1_OPTIONS="subq=1:bframes=3:b_pyramid:weight_b:turbo=1"
VIDEO_CODEC_PASS2_OPTIONS="subq=6:bframes=3:b_pyramid:weight_b:8x8dct:frameref=5:partitions=all:me=umh"
VIDEO_CODEC_OPTIONS="subq=5:8x8dct:frameref=2:bframes=3:b_pyramid:weight_b"

# Default Output Format
# You should set this to rawvideo if you are encoding with
# x264, if this value is empty, -of will not be passed to mencoder
# Don't forget to check mencoder manual before changing this value.
VIDEO_OF="rawvideo"

# If your video codec is lavc then you MUST define this!
LAVC_VIDEO_CODEC="mpeg4"

# Default AC3 Bitrate
AUDIO_AC3_BITRATE="320"

# Default MP3 Bitrate
AUDIO_MP3_BITRATE="192"
EOF

    print_info 0 "dvd2mkv has been properly configured, Thank you ..."
    sleep 2
}

INFO_main_menu()
{
    local key
    INFO_main_menu_display
    while true; do
        unset key
        read -sn1 key
        case "${key}" in
            1)
                INFO_general_menu
                INFO_main_menu_display
                continue
                ;;
            2)
                INFO_video_menu
                INFO_main_menu_display
                continue
                ;;
            3)
                INFO_audio_menu
                INFO_main_menu_display
                continue
                ;;
            4)
                INFO_subtitle_menu
                INFO_main_menu_display
                continue
                ;;
            0)
                break
                ;;
            *)
                continue
                ;;
        esac
    done
    return 0
}

INFO_main_menu_display()
{
    clear
    print_info 0 "Main menu"
    print_menu 1 "General details."
    print_menu 2 "Video details."
    print_menu 3 "Audio details."
    print_menu 4 "Subtitle details."
    echo
    print_menu 0 "Begin ripping process."
}

INFO_general_menu()
{
    local key rippath answer
    INFO_general_menu_display
    while true; do
        unset key
        read -sn 1 key
        case "${key}" in
            0)
                break
                ;;
            1)
                clear
                print_info 0 "Rip path settings."
                print_info 1 "Current RIPPATH: '${FG_GREEN}${RIPPATH}${FG_CLEAR}'."
                print_info 2 "please enter the new RIPPATH (empty to cancel): " false
                read rippath
                [[ -n "${rippath}" ]] && RIPPATH="${RIPPATH}"
                INFO_general_menu_display
                continue
                ;;
            2)
                clear
                print_info 0 "Keep riped files."
                if isTrue "${KEEP_RIPED_FILES}"; then
                    print_info 1 "Currently the script does not remove any of the ripped files,"
                else
                    print_info 1 "Currently the script remove all ripped files,"
                fi
                    print_info 1 "this is usefull in case you have made a mistake, this way you"
                    print_info 1 "can easly re-run this script and use some of the already riped files"
                if isTrue "${KEEP_RIPED_FILES}"; then
                    print_info 2 "Would you like to disable it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        KEEP_RIPED_FILES=false
                    fi
                else
                    print_info 2 "Would you like to enable it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        KEEP_RIPED_FILES=true
                    fi
                fi
                INFO_general_menu_display
                ;;
            *)
                continue
                ;;
        esac
    done
}

INFO_general_menu_display()
{
    clear
    print_info 0 "General details."
    print_menu 1 "Rip Path (where all ripped files will be): '${FG_GREEN}${RIPPATH}${FG_BLUE}'."
    print_menu 2 "Keep files?: '${FG_GREEN}${KEEP_RIPED_FILES}${FG_BLUE}'."
    echo
    print_menu 0 "Main menu."
}

INFO_video_menu()
{
    local i Available_Codecs Available_OF key temp
    INFO_video_menu_display
    while true; do
        unset key
        read -sn 1 key
        case "${key}" in
            0)
                break
                ;;
            1)
                clear
                print_info 0 "Video codec"
                print_info 1 "Supported codecs:" false
                i=0
                Available_Codecs="$( $(which mencoder) -ovc help | tac | sed -e '/Available codecs:/,$d' -e 's@^[ \t]*@@g' | cut -d' ' -f1)"
                for temp in ${Available_Codecs[@]}; do
                    [[ "${temp}" = "frameno" ]] && continue
                    if [ "$[ ${i} % 2 ]" -eq "0" ]; then
                        echo
                        print_info 0 "                   " false false
                    else
                        print_info 0 " " false false
                    fi
                    print_info 0 "${temp}" false false
                    (( i++ ))
                done
                echo
                temp=false
                while ! inArray ${temp} ${Available_Codecs[@]}; do
                    print_info 1 "Please enter the desired codec (empty to cancel): " false
                    read temp
                    [[ -z "${temp}" ]] && temp="${VIDEO_CODEC}"
                done
                VIDEO_CODEC="${temp}"
                INFO_video_menu_display
                continue
                ;;
            2)
                clear
                print_info 0 "Video Bitrate."
                print_info 1 "Current video bitrate: '${FG_GREEN}${VIDEO_BITRATE}${FG_CLEAR}'."
                print_info 2 "please enter the new bitrate (empty to cancel): " false
                read temp
                [[ -n "${temp}" ]] && RIPPATH="${temp}"
                INFO_video_menu_display
                continue
                ;;
            3)
                clear
                print_info 0 "Video Filter Options."
                print_info 1 "Current video filter options: '${FG_GREEN}${VF_OPTIONS}${FG_CLEAR}'."
                print_info 2 "please enter the new options (empty to cancel): " false
                read temp
                [[ -n "${temp}" ]] && VF_OPTIONS="${temp}"
                INFO_video_menu_display
                continue
                ;;
            4)
                clear
                print_info 0 "Video Output Format."
                print_info 1 "Supported formats:" false
                i=0
                Available_OF="$( $(which mencoder) -of help | tac | sed -e '/Available output formats:/,$d' -e 's@^[ \t]*@@g' | cut -d' ' -f1)"
                for temp in ${Available_OF[@]}; do
                    if [ "$[ ${i} % 2 ]" -eq "0" ]; then
                        echo
                        print_info 0 "                    " false false
                    else
                        print_info 0 " " false false
                    fi
                    print_info 0 "${temp}" false false
                    (( i++ ))
                done
                echo
                temp=false
                while ! inArray ${temp} ${Available_OF[@]}; do
                    print_info 1 "Please enter the desired codec (empty to cancel): " false
                    read temp
                    [[ -z "${temp}" ]] && temp="${VIDEO_OF}"
                done
                VIDEO_OF="${temp}"
                INFO_video_menu_display
                continue
                ;;
            5)
                clear
                print_info 0 "Video Pass."
                print_info 1 "Current video pass: '${FG_GREEN}${VIDEO_PASS}${FG_CLEAR}'."
                temp=false
                while ! inArray ${temp} 1 2; do
                    print_info 2 "please enter the new number of passes [1-2] (empty to cancel): " false
                    read temp
                    [[ -z "${temp}" ]] && temp="${VIDEO_PASS}"
                done
                VIDEO_PASS="${temp}"
                INFO_video_menu_display
                continue
                ;;
            6)
                clear
                print_info 0 "Video Crop."
                print_info 1 "Current video crop: '${FG_GREEN}${DVD_crop}${FG_CLEAR}'."
                print_info 2 "please enter the new crop (empty to cancel, -1 to re-detect it): " false
                read temp
                if [ "${temp}" -eq "-1" ]; then
                    GET_crop
                elif [ -n "${temp}" ]; then
                    DVD_crop="${temp}"
                fi
                INFO_video_menu_display
                continue
                ;;
            7)
                clear
                if [ "${VIDEO_PASS}" -eq "2" ]; then
                    print_info 0 "Video Codec pass1 options."
                    print_info 1 "Current video codec pass1 options: '${FG_GREEN}${VIDEO_CODEC_PASS1_OPTIONS}${FG_CLEAR}'."
                    print_info 2 "please enter the new options (empty to cancel): " false
                    read temp
                    [[ -n "${temp}" ]] && VIDEO_CODEC_PASS1_OPTIONS="${temp}"
                else
                    print_info 0 "Video Codec options."
                    print_info 1 "Current video codec options: '${FG_GREEN}${VIDEO_CODEC_OPTIONS}${FG_CLEAR}'."
                    print_info 2 "please enter the new options (empty to cancel): " false
                    read temp
                    [[ -n "${temp}" ]] && VIDEO_CODEC_OPTIONS="${temp}"
                fi
                INFO_video_menu_display
                continue
                ;;
            8)
                clear
                print_info 0 "Video Codec pass2 options."
                print_info 1 "Current video codec pass2 options: '${FG_GREEN}${VIDEO_CODEC_PASS2_OPTIONS}${FG_CLEAR}'."
                print_info 2 "please enter the new options (empty to cancel): " false
                read temp
                [[ -n "${temp}" ]] && VIDEO_CODEC_PASS2_OPTIONS="${temp}"
                INFO_video_menu_display
                continue
                ;;
            *)
                continue
                ;;
        esac
    done
    return 0
}

INFO_video_menu_display()
{
    clear
    print_info 0 "Video menu."
    print_menu 1 "Video codec: '${FG_GREEN}${VIDEO_CODEC}${FG_BLUE}'."
    print_menu 2 "Video bitrate: '${FG_GREEN}${VIDEO_BITRATE}${FG_BLUE}'."
    print_menu 3 "Video filter options: '${FG_GREEN}${VF_OPTIONS}${FG_BLUE}'."
    print_menu 4 "Video output format: '${FG_GREEN}${VIDEO_OF}${FG_BLUE}'."
    print_menu 5 "Video pass: '${FG_GREEN}${VIDEO_PASS}${FG_BLUE}'."
    print_menu 6 "Video crop: '${FG_GREEN}${DVD_crop}${FG_BLUE}'."
    if [ "${VIDEO_PASS}" -eq "2" ]; then
        print_menu 7 "Video codec pass1 options: '${FG_GREEN}${VIDEO_CODEC_PASS1_OPTIONS}${FG_BLUE}'."
        print_menu 8 "Video codec pass2 options: '${FG_GREEN}${VIDEO_CODEC_PASS2_OPTIONS}${FG_BLUE}'."
    else
        print_menu 7 "Video codec options: '${FG_GREEN}${VIDEO_CODEC_OPTIONS}'${FG_BLUE}."
    fi
    echo
    print_menu 0 "Main menu."
}

INFO_audio_menu()
{
    local i
    if [ "${#DVD_audio_tracks[@]}" -lt "1" ]; then
        # We don't have any audio track!
        clear
        print_error 0 "No audio tracks found."
        print_info 1 "Press any key to continue." true false
        read -sn 1 key
        return 1
    fi
    INFO_audio_menu_display
    while true; do
        unset key
        echo
        print_info 0 "Which track to edit? " true false
        read key
        [[ "${key}" -eq "0" ]] && break
        (( i = key - 1 ))
        if [ -z "${DVD_audio_tracks[$i]}" ]; then
            INFO_audio_menu_display
            continue
        fi
        INFO_audio_edit_menu "${i}"
        INFO_audio_menu_display
    done
    return 0
}

INFO_audio_menu_display()
{
    local i=1 track aid lang format channels bitrate active
    clear
    print_info 0 "Audio menu."
    for track in ${DVD_audio_tracks[@]}; do
        aid="$(echo ${track} | cut -d':' -f1)"
        lang="$(echo ${track} | cut -d':' -f2)"
        format="$(echo ${track} | cut -d':' -f3)"
        channels="$(echo ${track} | cut -d':' -f4)"
        bitrate="$(echo ${track} | cut -d':' -f5)"
        active="$(echo ${track} | cut -d':' -f6)"
        print_menu "${i}" "AID=${FG_GREEN}${aid}${FG_CLEAR}, Lang=${FG_GREEN}${lang}${FG_CLEAR}, Format=${FG_GREEN}${format}${FG_CLEAR}, Channels=${FG_GREEN}${channels}${FG_CLEAR}, Bitrate=${FG_GREEN}${bitrate}${FG_CLEAR} and Active=${FG_GREEN}${active}${FG_CLEAR}"
        (( i++ ))
    done
    echo
    print_menu 0 "Main menu"
}

INFO_audio_edit_menu()
{
    local i
    [ -z "${1}" ] && return 1
    track="${DVD_audio_tracks[$1]}"
    aid="$(echo ${track} | cut -d':' -f1)"
    lang="$(echo ${track} | cut -d':' -f2)"
    format="$(echo ${track} | cut -d':' -f3)"
    channels="$(echo ${track} | cut -d':' -f4)"
    bitrate="$(echo ${track} | cut -d':' -f5)"
    active="$(echo ${track} | cut -d':' -f6)"
    INFO_audio_edit_menu_display "${1}"
    while true; do
        unset key
        read -sn 1 key
        case "${key}" in
            0)
                break
                ;;
            1)
                clear
                print_info 0 "Previewing the track ${FG_GREEN}${aid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                print_info 1 "Opening mplayer... " false
                $(which mplayer) dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -aid ${aid} &> /dev/null &
                print_info 1 "Done." true false
                print_info 2 "Press any key to go back."
                read -sn 1 key
                INFO_audio_edit_menu_display "${1}"
                continue
                ;;
            2)
                clear
                print_info 0 "Editing the format of the track ${FG_GREEN}${aid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                temp=false
                while ! inArray "${temp}" ac3 mp3; do
                    print_info 1 "Please enter the new format (empty to cancel) : " false
                    read temp
                    [[ -z "${temp}" ]] && temp="${format}"
                done
                format="${temp}"
                DVD_audio_tracks[$1]="${aid}:${lang}:${format}:${channels}:${bitrate}:${active}"
                INFO_audio_edit_menu_display "${1}"
                continue
                ;;
            3)
                #TODO: channels
                #      look below at INFO_audio_edit_menu_display()
                continue
                ;;
            4)
                clear
                print_info 0 "Editing the bitrate of the track ${FG_GREEN}${aid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                temp=false
                while ! isNumber "${temp}"; do
                    print_info 1 "Please enter the new bitrate (empty to cancel) : " false
                    read temp
                    [[ -z "${temp}" ]] && temp="${bitrate}"
                done
                bitrate="${temp}"
                DVD_audio_tracks[$1]="${aid}:${lang}:${format}:${channels}:${bitrate}:${active}"
                INFO_audio_edit_menu_display "${1}"
                continue
                ;;
            5)
                clear
                print_info 0 "Editing the status of the track ${FG_GREEN}${aid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                print_info 1 "NOTE: An active track is a track that is going to be ripped and included in the mkv file."
                if isTrue "${active}"; then
                    print_info 1 "The current track is active, would you like to desactivate it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        active=false
                    fi
                else
                    print_info 1 "The current track is not active, would you like to activate it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        active=true
                    fi
                fi
                DVD_audio_tracks[$1]="${aid}:${lang}:${format}:${channels}:${bitrate}:${active}"
                INFO_audio_edit_menu_display "${1}"
                continue
                ;;
            *)
                continue
                ;;
        esac
    done
    unset track aid lang format channels active answer
    return 0
}

INFO_audio_edit_menu_display()
{
    local i
    clear
    print_info 0 "Editing audio details of track ${FG_GREEN}${aid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
    print_menu 1 "Preview this track."
    print_menu 2 "Edit the format of this track."
    print_menu 3 "Edit the channels of this track."
    print_menu 4 "Edit the bitrate of this track."
    print_menu 5 "Activate/Desactive this track..."
    echo
    print_menu 0 "Go back to Audio menu"
}

INFO_subtitle_menu()
{
    local i key
    if [ "${#DVD_subtitle_tracks[@]}" -lt "1" ]; then
        # We don't have any subtitle track!
        clear
        print_error 0 "No subtitle tracks found."
        print_info 1 "Press any key to continue." true false
        read -sn 1 key
        return 1
    fi
    INFO_subtitle_menu_display
    while true; do
        unset key
        echo
        print_info 0 "Which track to edit? " true false
        read key
        [[ "${key}" -eq "0" ]] && break
        (( i = key - 1 ))
        if [ -z "${DVD_subtitle_tracks[$i]}" ]; then
            INFO_subtitle_menu_display
            continue
        fi
        INFO_subtitle_edit_menu "${i}"
        INFO_subtitle_menu_display
    done
    return 0
}

INFO_subtitle_menu_display()
{
    local i=1 sid track lang active
    clear
    print_info 0 "Subtitle menu."
    for track in ${DVD_subtitle_tracks[@]}; do
        sid="$(echo ${track} | cut -d':' -f1)"
        lang="$(echo ${track} | cut -d':' -f2)"
        active="$(echo ${track} | cut -d':' -f3)"
        print_menu "${i}" "SID=${FG_GREEN}${sid}${FG_CLEAR}, Lang=${FG_GREEN}${lang}${FG_CLEAR} and Active=${FG_GREEN}${active}${FG_CLEAR}"
        (( i++ ))
    done
    echo
    print_menu 0 "Main menu"
}

INFO_subtitle_edit_menu()
{
    local i
    [ -z "${1}" ] && return 1
    track="${DVD_subtitle_tracks[$1]}"
    sid="$(echo ${track} | cut -d':' -f1)"
    lang="$(echo ${track} | cut -d':' -f2)"
    active="$(echo ${track} | cut -d':' -f3)"
    INFO_subtitle_edit_menu_display "${1}"
    while true; do
        unset key
        read -sn 1 key
        case "${key}" in
            0)
                break
                ;;
            1)
                clear
                print_info 0 "Previewing the track ${FG_GREEN}${sid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                print_info 1 "Opening mplayer... " false
                $(which mplayer) dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -sid ${sid} &> /dev/null &
                print_info 1 "Done." true false
                print_info 2 "Press any key to go back."
                read -sn 1 key
                INFO_subtitle_edit_menu_display "${1}"
                continue
                ;;
            2)
                clear
                print_info 0 "Editing the status of the track ${FG_GREEN}${sid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
                print_info 1 "NOTE: An active track is a track that is going to be ripped and included in the mkv file."
                if isTrue "${active}"; then
                    print_info 1 "The current track is active, would you like to desactivate it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        active=false
                    fi
                else
                    print_info 1 "The current track is not active, would you like to activate it [y/n] : " false
                    read -sn 1 answer; echo
                    if isTrue "${answer}"; then
                        active=true
                    fi
                fi
                DVD_subtitle_tracks[$1]="${sid}:${lang}:${active}"
                INFO_subtitle_edit_menu_display "${1}"
                continue
                ;;
            *)
                continue
                ;;
        esac
    done
    unset track sid lang active answer
    return 0
}

INFO_subtitle_edit_menu_display()
{
    local i
    clear
    print_info 0 "Editing subtitle details of track ${FG_GREEN}${sid}${FG_WHITE_B}, where it's language is ${FG_GREEN}${lang}${FG_WHITE_B}."
    print_menu 1 "Preview this track."
    print_menu 2 "Activate/Desactive this track..."
    echo
    print_menu 0 "Go back to Subtitle menu"
}

GET_dvd_info()
{
    print_info 0 "Gathering information on the current dvd."

    # Longest Track
    GET_longest_track

    # DVD Title
    GET_dvd_title

    # DVD X, Y and Aspect Ratio
    GET_dvd_width_heigh_aspect_ratio

    # Audio and Subtitle Tracks
    GET_audio_subtitle

    # Done 'Gathering information on the current dvd.'
    print_info 0 "Done."
}

GET_longest_track()
{
    local answer
    print_info 2 "Is this a movie? (no if you want to rip a specific track) [y/n] : " false
    read -sn 1 answer; echo
    if isTrue "${answer}"; then
        print_info 3 "Obtaining the longest track number... " false
        DVD_longest_track="$(lsdvd -q "${DVD_DEVICE}" 2> /dev/null | grep "Longest track:" | cut -d':' -f2 | cut -c 2-)"
        print_info 3 "Done." true false
    else
        while ! isNumber "${DVD_longest_track}"; do
            print_info 3 "Please enter the track number : " false
            read DVD_longest_track
        done
    fi
    if debug; then
        print_info 3 "Longuest Track: ${FG_GREEN}${DVD_longest_track}${FG_CLEAR}"
    fi
}

GET_dvd_title()
{
    print_info 2 "Obtaining the DVD title... " false
    DVD_title="$(lsdvd -q "${DVD_DEVICE}" 2> /dev/null | grep "Disc Title:" | cut -d':' -f2 | cut -c 2-)"
    print_info 2 "Done." true false
    while [ -z "${DVD_title}" ]; do
        print_info 3 "I couldn't retrive the title myself, please enter the title manually (case sensitive) : " false
        read DVD_title
    done
    if debug; then
        print_info 3 "DVD Title: ${FG_GREEN}${DVD_title}${FG_CLEAR}"
    fi
    RIPPATH="${TEMP}/dvdrip/${DVD_title}/work"
    OUTPUT="${TEMP}/dvdtip/${DVD_title}.mkv"
}

GET_dvd_width_heigh_aspect_ratio()
{
    print_info 2 "Obtaining the DVD width, height and aspect ratio... " false
    local video_info="$(lsdvd -v -q -t ${DVD_longest_track} ${DVD_DEVICE} 2> /dev/null | grep 'Aspect ratio')"
    DVD_original_x="$(echo "${video_info}" | sed -e 's@.*Width:\ \([0-9]\{3,\}\).*Height:\ [0-9]\{3,\}.*@\1@g')"
    DVD_original_y="$(echo "${video_info}" | sed -e 's@.*Width:\ [0-9]\{3,\}.*Height:\ \([0-9]\{3,\}\).*@\1@g')"
    DVD_aspect_ratio="$(echo "${video_info}" | cut -f 5 -d \, | cut -f 2 -d \: | cut -c 2-)"
    DVD_original_fps="$(echo "${video_info}" | cut -f 3 -d \, | cut -f 2 -d \: | cut -c 2-)"
    print_info 2 "Done." true false
}

GET_audio_subtitle()
{
    DVD_audio_tracks=()
    DVD_subtitle_tracks=()

    print_info 2 "Gathering information on available audio and subtitle tracks."
    tracks_info_file="${TEMP_FOLDER}/tracks_info_file"
    audio_tracks_info_file="${TEMP_FOLDER}/audio_tracks_info_file"
    subtitle_tracks_info_file="${TEMP_FOLDER}/subtitle_tracks_info_file"
    $(which mplayer) -identify -vf pp=-lb/-li/-ci/-md/-fd -nosound -vo null -frames 0 -v -dvd-device "${DVD_DEVICE}" dvd://${DVD_longest_track} 1> "${tracks_info_file}" 2> /dev/null

    # Gather audio information
    GET_audio
    GET_subtitle

    # Done 'Gathering information on audio and subtitle tracks'
    print_info 2 "Done."
}

GET_audio()
{
    local aid lang format channels bitrate temp
    # Detecting available audio tracks
    print_info 3 "Detecing audio tracks."
    grep "ID_AUDIO_ID=" "${tracks_info_file}" > "${audio_tracks_info_file}"
    while read line; do
        unset aid
        aid="$(echo "${line}" | cut -d'=' -f2)"
        print_info 4 "Found audio track ID=${FG_GREEN}${aid}${FG_CLEAR}."
        temp=(${temp[@]} "${aid}")
    done < "${audio_tracks_info_file}"
    DVD_audio_tracks=(${temp[@]})
    print_info 3 "Done."
    unset temp

    # Gathering information on audio tracks
    print_info 3 "Gathering information on available audio tracks (language and format)."
    for aid in ${DVD_audio_tracks[@]}; do
        unset lang format channels

        # Obtaining the lang of this track
        if ! grep -q "ID_AID_${aid}_LANG=" "${tracks_info_file}"; then
            while [ -z "${lang}" ]; do
                print_warning 4 "I couldn't detect the language of AID=${FG_GREEN}${aid}${FG_CLEAR}, please specify it : " false
                read lang
            done
        else
            lang="$(grep "ID_AID_${aid}_LANG=" "${tracks_info_file}" | cut -d'=' -f2)"
            print_info 4 "I detected the language of AID=${FG_GREEN}${aid}${FG_CLEAR}: ${FG_MAGNETA}${lang}${FG_CLEAR}"
        fi

        # obtaining the format of this track
        if ! grep -q "audio stream:.* format:.* language: .* aid: ${aid}" "${tracks_info_file}"; then
            while [ -z "${format}" ]; do
                print_warning 4 "I can't find a reference to the format of AID=${FG_GREEN}${aid}${FG_CLEAR}, please specify it : " false
                read format
            done
        else
            format="$(grep "audio stream:.* format:.* language: .* aid: ${aid}" "${tracks_info_file}" | cut -d' ' -f5)"
            print_info 5 "I detected the format of AID=${FG_GREEN}${aid}${FG_CLEAR}: ${FG_MAGNETA}${format}${FG_CLEAR}"
        fi

        # Since we got the format, we can set the bitrate
        if [ "${format}" = "ac3" ]; then
            bitrate="${AUDIO_AC3_BITRATE}"
        elif [ "${format}" = "mpeg1" ]; then
            bitrate="${AUDIO_MP3_BITRATE}"
        fi

        # obtaining the channels of this track
        if ! grep -q "audio stream:.* format:.* (.*) language: .* aid: ${aid}" "${tracks_info_file}"; then
            while [ -z "${channels}" ]; do
                print_warning 4 "I can't find a reference to the channels of AID=${FG_GREEN}${aid}${FG_CLEAR}, please specify it : " false
                read channels
            done
        else
            channels="$(grep "audio stream:.* format:.* (.*) language: .* aid: ${aid}" "${tracks_info_file}" | sed -e "s@.*format: .* (\(.*\)).*@\1@g")"
            print_info 5 "I detected the channels of AID=${FG_GREEN}${aid}${FG_CLEAR}: ${FG_MAGNETA}${channels}${FG_CLEAR}"
        fi
        temp=(${temp[@]} "${aid}:${lang}:${format}:${channels}:${bitrate}:true")
    done
    DVD_audio_tracks=(${temp[@]})
    print_info 3 "Done."
}

GET_subtitle()
{
    local sid temp line lang
    # Detecting available subtitle tracks
    print_info 3 "Detecting subtitle tracks."
    grep "ID_SUBTITLE_ID=" "${tracks_info_file}" > "${subtitle_tracks_info_file}"
    while read line; do
        unset sid
        sid="$(echo "${line}" | cut -d'=' -f2)"
        print_info 4 "Found subtitle track ID=${FG_GREEN}${sid}${FG_CLEAR}."
        temp=(${temp[@]} "${sid}")
    done < "${subtitle_tracks_info_file}"
    DVD_subtitle_tracks=(${temp[@]})
    print_info 3 "Done."
    unset temp

    # Gathering information on subtitle tracks
    print_info 3 "Gathering information on available subtitle tracks (language)."
    for sid in ${DVD_subtitle_tracks[@]}; do
        unset lang

        # Obtaining the lang of this track
        if ! grep -q "ID_SID_${sid}_LANG=" "${tracks_info_file}"; then
            while [ -z "${lang}" ]; do
                print_warning 4 "I couldn't detect the language of SID=${sid}, please specify it : " false
                read lang
            done
        else
            lang="$(grep "ID_SID_${sid}_LANG=" "${tracks_info_file}" | cut -d'=' -f2)"
            print_info 4 "I detected the language of SID=${FG_GREEN}${sid}${FG_CLEAR}: ${FG_MAGNETA}${lang}${FG_CLEAR}"
        fi
        temp=(${temp[@]} "${sid}:${lang}:false")
    done
    DVD_subtitle_tracks=(${temp[@]})
    print_info 3 "Done."
}

PRE_cache_dvd()
{
    local answer
    print_info 0 "Should I cache the DVD to the Hard Disk?"
    print_info 1 "You should have at least 10 Gb on the Hard Disk to be able to cache it,"
    print_info 1 "Caching the DVD allow you to remove it from the drive also, it may"
    print_info 1 "speed up encoding the vob files..."
    print_info 2 "Proceed with Caching? [y/n] : " false
    read -sn 1 answer; echo
    if isTrue "${answer}"; then
        # Does the folder $TEMP/fulldvd exist?
        if [ -d "${TEMP}/fulldvd" ]; then
            if [ -d "${TEMP}/fulldvd/${DVD_title}/video_ts" -o -d "${TEMP}/fulldvd/${DVD_title}/VIDEO_TS" ]; then
                print_info 3 "A dvd has been already cached in '${FG_GREEN}${TEMP}/fulldvd/${DVD_title}${FG_CLEAR}', use it [y/n] : " false
                read -sn 1 answer; echo
                if isTrue "${answer}"; then
                    DVD_CACHED=true
                else
                    die "Please take care of the folder '${FG_GREEN}${TEMP}/fulldvd/${DVD_title}${FG_CLEAR}' manually."
                fi
            else
                # Not a DVD folder, is it empty?
                if [ -d "${TEMP}/fulldvd/${DVD_title}" ]; then
                    if [ "$(ls ${TEMP}/fulldvd/${DVD_title} | wc -l )" -ne "0" ]; then
                        die "Please take care of the folder '${FG_GREEN}${TEMP}/fulldvd/${DVD_title}${FG_CLEAR}' manually."
                        fi
                fi
            fi
        else
            mkdir -p "${TEMP}/fulldvd"
        fi
        if ! isTrue "${DVD_CACHED}"; then
            print_info 1 "Caching DVD ${FG_GREEN}${DVD_DEVICE} ${FG_CLEAR}(${FG_YELLOW}${DVD_title}${FG_CLEAR}) to '${FG_GREEN}${TEMP}/fulldvd${FG_CLEAR}'"
#            print_info 2 "Caching track '${FG_GREEN}0${FG_CLEAR}' ... " false
#            log $(which dvdbackup) -i "${DVD_DEVICE}" -T 0 -o "${TEMP}/fulldvd"
#            $(which dvdbackup) -i "${DVD_DEVICE}" -T 0 -o "${TEMP}/fulldvd" >> "${LOG}"
#            scan_return_code $?
#            print_info 2 "Done." true false
#            print_info 2 "Caching track '${FG_GREEN}${DVD_longest_track}${FG_CLEAR}' ... " false
#            log $(which dvdbackup) -i "${DVD_DEVICE}" -t "${DVD_longest_track}" -o "${TEMP}/fulldvd"
#            $(which dvdbackup) -i "${DVD_DEVICE}" -t "${DVD_longest_track}" -o "${TEMP}/fulldvd" >> "${LOG}"
#            scan_return_code $?
#            print_info 2 "Done." true false
            print_info 2 "Caching the whole dvd ... " false
            log $(which dvdbackup) -i "${DVD_DEVICE}" -M -o "${TEMP}/fulldvd"
            $(which dvdbackup) -i "${DVD_DEVICE}" -M -o "${TEMP}/fulldvd" >> "${LOG}"
            scan_return_code $?
            print_info 2 "Done." true false
            DVD_CACHED=true
        fi
        DVD_PATH="${TEMP}/fulldvd/${DVD_title}"
    else
        DVD_PATH="${DVD_DEVICE}"
    fi
}

GET_crop()
{
    local answer threshold temp_x temp_y sum_x line
    local sum_y ave_x ave_y x_offset y_offset n

    print_info 0 "Calculating crop value."

    # Take the reference screenshot
    print_info 2 "Taking the reference screenshot... " false
    cd "${TEMP_SCREENSHOTS}"
    mplayer dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -vo jpeg -nosound -ss 300 -frames 6 &> /dev/null
    mv -f 00000005.jpg ${TEMP}/screenshot-reference.jpg
    rm -f -- *
    print_info 2 "Done." true false
    print_info 2 "Opening the reference image. (Don't close the window unless you are done with crop detection)... " false
    ${IMAGE_VIEWER} "${TEMP}/screenshot-reference.jpg" && rm -f "${TEMP}/screenshot-reference.jpg" &
    print_info 2 "Done." true false

    print_info 2 "Calculating threshold."
    threshold=50
    while true; do
        print_info 3 "Calculating crop size for threshold ${FG_GREEN}${threshold}${FG_CLEAR}... " false
        $(which mplayer) dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -vo null -vf cropdetect=${threshold}:16 -nosound -ss 300 -frames 300 2> /dev/null | grep "Crop area:" > ${TEMP_FOLDER}/crop_buff
        print_info 3 "Done." true false

        # Reset temporary variables
        n=0
        temp_x=0
        temp_y=0
        sum_x=0
        sum_y=0
        ave_x=0
        ave_y=0

        # Process buffer and sum up all cropped propositions
        while read line; do
            temp_x="$(echo "${line}" | sed -e 's@.*crop=-*\([0-9]*\):-*[0-9]*:-*[0-9]*:-*[0-9]*.*@\1@g')"
            temp_y="$(echo "${line}" | sed -e 's@.*crop=-*[0-9]*:-*\([0-9]*\):-*[0-9]*:-*[0-9]*.*@\1@g')"

            (( sum_x += ${temp_x} ))
            (( sum_y += ${temp_y} ))
            (( n++ ))
        done < "${TEMP_FOLDER}/crop_buff"

        print_info 3 "Calculating average and offset of X and Y... " false
        # Build average
        (( ave_x = ${sum_x} / ${n} ))
        (( ave_y = ${sum_y} / ${n} ))

        # Make a multiple of 16
        ave_x="$(make_16 ${ave_x})"
        ave_y="$(make_16 ${ave_y})"

        # Build offset
        (( x_offset = ( ${DVD_original_x} - ${ave_x} ) / 2 ))
        (( y_offset = ( ${DVD_original_y} - ${ave_y} ) / 2 ))

        # Make offset a multiple of 2
        if [ "$(expr ${x_offset} % 2)" -eq "1" ]; then
            (( x_offset -= 1 ))
        fi

        if [ "$(expr ${y_offset} % 2)" -eq "1" ]; then
            (( y_offset -=  1 ))
        fi
        print_info 3 "Done." true false

        print_info 3 "Taking a screenshot with the new crop value... " false
        mplayer dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -nosound -ss 300 -frames 6 -vo jpeg -vf crop=${ave_x}:${ave_y}:${x_offset}:${y_offset},pp=-lb/-li/-ci/-md/-fd &> /dev/null
        print_info 3 "Done." true false
        mv -f "${TEMP_SCREENSHOTS}/00000005.jpg" "${TEMP}/screenshot-threshold-${threshold}.jpg"
        rm -f -- *
        print_info 4 "Opening the screenshot for threshold ${FG_GREEN}${threshold}${FG_CLEAR}... " false
        ${IMAGE_VIEWER} "${TEMP}/screenshot-threshold-${threshold}.jpg" && rm -f -- "${TEMP}/screenshot-threshold-${threshold}.jpg" &
        print_info 4 "Done." true false

        print_info 3 "Does this threshold (${FG_YELLOW}${threshold}${FG_CLEAR}) seem correct? [y/n] : " false
        read -sn 1 answer; echo
        if isTrue ${answer}; then
            break
        else
            unset threshold
            while [ -z "${threshold}" ]; do
                print_info 4 "Please enter the new threshold value [0-255]: " false
                read threshold; echo
            done
        fi
    done
    DVD_threshold="${threshold}"
    DVD_crop="${ave_x}:${ave_y}:${x_offset}:${y_offset}"
    print_info 0 "Done."
}

RIP_dvd()
{
    # Ok at this point we have to make sure that RIPPATH does exist!
    if [ ! -d "${RIPPATH}" ]; then
        mkdir -p "${RIPPATH}"
    fi

    # Starting to Rip video audio and subtitle
    RIP_video || die "Couldn't rip video."
    echo
    RIP_audio || die "Couldn't rip audio."
    echo
    RIP_subtitle || die "Couldn't rip subtitles."
    return 0
}

RIP_video()
{
    local answer options temp
    if [ "${VIDEO_OF}" = "rawvideo" ]; then
        local video_file="${RIPPATH}/videotrack-${DVD_longest_track}.rawvideo"
        DVD_video_file="${RIPPATH}/videotrack-${DVD_longest_track}"
    else
        DVD_video_file="${RIPPATH}/videotrack-${DVD_longest_track}"
        local video_file="${DVD_video_file}"
    fi
    clear
    print_info 0 "Video track ripping."
    if [ -f "${DVD_video_file}" ]; then
        print_info 1 "The file ${DVD_video_file} already exist, would you like to use it? [y/n] " false
        read -sn 1 answer; echo
        if isTrue "${answer}"; then
            return 0
        fi
    fi

    # Ok let's start the ripping process
    # Whatever the command I launch, I will put it in ${FG_CYAN_B}

    # Constructing mencoder common options
    options="dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -nosound -of ${VIDEO_OF} -o ${video_file}"
    if [ -z "${VF_OPTIONS}" ]; then
        options="${options} -vf crop=${DVD_crop}"
    else
        options="${options} -vf ${VF_OPTIONS},crop=${DVD_crop}"
    fi
    options="${options} -ovc ${VIDEO_CODEC}"
    if [ "${VIDEO_CODEC}" = "x264" ]; then
        options="${options} -x264encopts bitrate=${VIDEO_BITRATE}"
    elif [ "${VIDEO_CODEC}" = "xvid" ]; then
        options="${options} -xvidencopts bitrate=${VIDEO_BITRATE}"
    elif [ "${VIDEO_CODEC}" = "lavc" ]; then
        options="${options} -lavcopts vcodec=${LAVC_VIDEO_CODEC}:vbitrate=${VIDEO_BITRATE}"
    else
        die "I am sorry but I have no knowledge of the codec ${VIDEO_CODEC}."
    fi

    if [ "${VIDEO_PASS}" = "2" ]; then
        # Ripping with 2 passes

        # First pass
        temp="${options}:${VIDEO_CODEC_PASS1_OPTIONS}:pass=1"
        print_info 2 "Starting 1st pass video encoding."
        echo -e "${FG_CYAN_B}"
        $(which mencoder) ${temp}
        echo -e "${FG_CLEAR}"
        print_info 2 "1st pass video encoding is done."

        # Second pass
        temp="${options}:${VIDEO_CODEC_PASS2_OPTIONS}:pass=2"
        print_info 2 "Starting 2nd pass video encoding."
        echo -e "${FG_CYAN_B}"
        $(which mencoder) ${temp}
        echo -e "${FG_CLEAR}"
        print_info 2 "2nd pass video encoding is done."
    elif [ "${VIDEO_PASS}" = "1" ]; then
        # Ripping with 1 pass (NOT very bright for DVD ripping though!
        temp="${options}:${VIDEO_CODEC_OPTIONS}"
        print_info 2 "Starting video encoding."
        echo -e "${FG_CYAN_B}"
        $(which mencoder) ${temp}
        echo -e "${FG_CLEAR}"
        print_info 2 "video encoding is done."
    fi

    # If VIDEO_OF is rawvideo, we have to put in a container.
    if [ "${VIDEO_OF}" = "rawvideo" ]; then
        case "${VIDEO_CODEC}" in
            "x264")
                print_info 2 "Putting the rawvideo file in a container."
                echo -e "${FG_CYAN_B}"
                $(which mp4creator) -c "${video_file}" -rate "${DVD_original_fps}" "${DVD_video_file}"
                echo -e "${FG_CLEAR}"
                print_info 2 "The rawvideo file has been added in a container."
                ;;
        esac
    fi
    print_info 0 "Video encoding is done."
}

RIP_audio()
{
    local track aid lang format channels bitrate active options temp audio_file
    if [ "${#DVD_audio_tracks[@]}" -lt "1" ]; then
        # We don't have any audio track!
        clear
        print_warning 0 "WARNING: No audio tracks found."
        return 0
    fi
    print_info 0 "Starting audio tracks ripping."
    # Construct common options
    # Codec and codec options would be in the specific track ripping.
    options="dvd://${DVD_longest_track} -dvd-device ${DVD_PATH} -ovc frameno -of rawaudio"
    for track in ${DVD_audio_tracks[@]}; do
        aid="$(echo ${track} | cut -d':' -f1)"
        lang="$(echo ${track} | cut -d':' -f2)"
        format="$(echo ${track} | cut -d':' -f3)"
        channels="$(echo ${track} | cut -d':' -f4)"
        bitrate="$(echo ${track} | cut -d':' -f5)"
        active="$(echo ${track} | cut -d':' -f6)"
        if isTrue "${active}"; then
            print_info 2 "Starting to rip audio track AID=${FG_GREEN}${aid}${FG_CLEAR}, Lang=${FG_GREEN}${lang}${FG_CLEAR}, Format=${FG_GREEN}${format}${FG_CLEAR}, Channels=${FG_GREEN}${channels}${FG_CLEAR} and Bitrate=${FG_GREEN}${bitrate}${FG_CLEAR}"
            # RIP it!
            audio_file="${RIPPATH}/audio-${DVD_longest_track}-${aid}"

            # TODO:
            #      Here I only took care of mp3 format, and I didn't even bother
            #      to look out for channels and stuff, but this is very wrong, so
            #      the if-clause below must be re-written and ac3 + channels must
            #      be taken care of.

            if [ "${format}" = "mp3" -o "${format}" = "mpeg1" ]; then
                temp="${options} -oac mp3lame -lameopts br=${bitrate}"
            elif [ "${format}" = "ac3" ]; then
                die "I am sorry but I have no knowledge of the format ${format}."
            else
                die "I am sorry but I have no knowledge of the format ${format}."
            fi

            # Finally add the file name.
            temp="${temp} -o ${audio_file}"

            # Rip this track
            echo -e "${FG_CYAN_B}"
            $(which mencoder) ${temp}
            echo -e "${FG_CLEAR}"
        else
            continue
        fi
    done
    print_info 0 "Audio tracks ripping is done."
    return 0
}

RIP_subtitle()
{
    local track sid lang active options temp subtitle_file
    if [ "${#DVD_subtitle_tracks[@]}" -lt "1" ]; then
        # We don't have any subtitle track!
        clear
        print_warning 0 "WARNING: No subtitle tracks found."
        return 0
    fi
    print_info 0 "Starting subtitle tracks ripping."
    for track in ${DVD_subtitle_tracks[@]}; do
        sid="$(echo ${track} | cut -d':' -f1)"
        lang="$(echo ${track} | cut -d':' -f2)"
        active="$(echo ${track} | cut -d':' -f3)"
        if isTrue "${active}"; then
            # Rip this subtitle track

            subtitle_file="${RIPPATH}/subs-${DVD_longest_track}-${sid}"

            # TODO: Rip subtitle track
        else
            continue
        fi
    done
    print_info 0 "Subtitle tracks rupping is done."
    return 0
}

#
####

# The user should not use this script under root!
not_root

DEBUG=false
DVD_CACHED=false
OLDPWD="$(pwd)"

# LOG file
LOG="$(mktemp /tmp/dvd2mkv.log.XXXXXXXX)"
TEMP_FOLDER="$(mktemp -d /tmp/dvd2mkv.XXXXXXXX)"
TEMP_SCREENSHOTS="${TEMP_FOLDER}/screenshots"
mkdir "${TEMP_SCREENSHOTS}"

if [ -f "${HOME}/.dvd2mkvrc" ]; then
    source "${HOME}/.dvd2mkvrc"
else
    configure
    source "${HOME}/.dvd2mkvrc"
fi

essential_programs=(mencoder mplayer lsdvd mkvmerge grep cut tr sed date bc seq echo oggenc ${IMAGE_VIEWER})

# Sanity Checks
for i in ${essential_programs[@]}; do
    if ! which ${i} &> /dev/null; then
        die "You don't seem to have ${i}, Please install it and try again."
    fi
done
if [ ! -d "${TEMP}" ]; then
    mkdir -p "${TEMP}"/{fulldvd,dvdrip}
fi

# Default values
DVD_PATH="${DVD_DEVICE}"

####
# Welcome our visitor
####
welcome
echo

####
# Getting All the informations we need about this DVD
# We begin by scanning for the longest track, then we need
# to obtain all Audio and Subtitles ID, language and (for audio) format.
####
GET_dvd_info
echo

####
# Should we cache the DVD??
####
PRE_cache_dvd
echo

####
# Determine crop size (Thanks to nrip)
# nrip is a bash script created by Alexey Abel <software@nforum.de>
# You can find nrip at http://www.nforum.de
####

####
# This process is actually quite simple, First we should take a
# reference screenshot, and open it (in background), then using
# mplayer we start by trying to guess the crop value with the
# threshold 50, if it cut too much, the user can change the
# threshold value then, the bigger the value is, the more of
# the image is cut.
# When the user get the right value, we then try to calculate
# the right crop values, crop format is like this:
# crop=${average_x}:${average_y}:${x_offset}:${y:offset}
# averge_x and average_y are calculated from mplayer output
# using the SAME threshold value.
# x_offset will be '(orig_x - average_x) / 2' where orig_x is
# determined from lsdvd...
####
GET_crop
echo

####
# Okay, Now we have all informations, What we ned is to display
# some menus to help user select/deselect and/or change format/bitrate
####

INFO_main_menu

clear
print_info 0 "Ripping DVD into a matroska video file."
print_info 1 "This process is going to take a long time to complete,"
print_info 1 "it depends on the speed of your hardware as well as the"
print_info 1 "length of the DVD you are about to rip."
print_info 2 "Would you like to continue? [y/n] " false
answer=false
read -sn 1 answer; echo
if ! isTrue "${answer}"; then
    exit_script
fi

# Start ripping the DVD
RIP_dvd

# Ok ripping eneded, we need to make the mkv file now.
