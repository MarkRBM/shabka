#!/bin/bash
#
# this patch can be found here:
#    http://www.jukie.net/~bart/scripts/tmp/vimdiff-on-git-merge-conflict
#
# this script uses git-cat, inspired by cg-admin-cat, it can be found here:
#    http://www.jukie.net/~bart/scripts/tmp/git-cat
#
# use case: you do a git pull and you have a merge conflict.  you want to review
#      all the chagnes and decide what to do for each conflict.  This script runs
#      a 3 way vimdiff over each of the files that is in conflict; the three
#      views are local file, merged/in-conflict file, and remote file.  You select
#      which deltas you want with 'do' (see :help do in vim), or edit the middle
#      pane manually.
#
# NOTE: this script will only work if the following conditions are met
#  .git/ORIG_HEAD                  - the HEAD before the merge started
#  .git/MERGE_HEAD                 - the commit ID we pulled / merged in
#  git status | grep unmerged      - a non empty list of files that need merging
#

set -u -e

# defaults
do_debug=
be_verbose=
do_am_merge=
do_status_only=
do_gitk_only=
conflict_markers="^\(<<<<<<<\|=======\|>>>>>>>\)"

prog=$(basename $0)
USAGE="$prog [-h]"

function bail {
        rc=$1 ; shift
        ((to=(rc?2:1)))
        echo $@ >&$to
        exit $rc
}

function warn {
        echo $@ >&2
}

function vecho {
        [ -z "$be_verbose" ] || echo $@ >&2
}

function help {
        rc=$1 ; shift
        ((to=($rc?2:1)))
        cat >&$to <<END
$USAGE
    -s                  status information
    -l                  list files that need work
    -k                  run gitk on BASE, MERGE, and HEAD
    --am                this is a git-am merge
    -v                  be verbose
    -d                  debug mode (set -x)
    -h                  print this help

END
        exit $rc
}

# fetch an id
function get_commit_id {
        name=$1
        [ -f .git/$name ] || bail 2 "$prog: .git/$name not present"
        id=$(cat .git/$name)
        warn "'${id:0:5}' = 'ref: '"
        if [ "${id:0:5}" = "ref: " ] ; then
                warn cat .git/${id:5}
                id=$(cat .git/${id:5})
        fi
		type=$(git cat-file -t "$id")
        [ "$type" = "commit" ] || bail 2 "$prog: .git/$name ($id) is not a commit"
        echo $id
}

# get list of files to work on
function get_unmerged_files {
        git status | grep unmerged | cut -d : -f 2
}

# status info
function dump_status {
        if [ ! -z "$do_am_merge" ] ; then
                echo "HEAD:  $am_head   # current branch"
                echo "PATCH: $am_patch   # next patch to apply"
        else
                echo "BASE:  $id_base   # common ancestor"
                echo "MERGE: $id_merge   # changes merging in "
                echo "HEAD:  $id_orig   # current branch"
        fi
        echo "FILES:"
        get_unmerged_files
}

# run gitk on BASE, MERGE, and HEAD
function run_gitk {
        gitk $id_base $id_merge $id_orig
}

# return true if repeat requested
function commit_repeat_prompt {
        file=$1
        conflict=$2
        res=xxx
        echo "Options:"
        echo " y - yes, resolve this file, updating the index, and move onto the next file"
        echo " n - no, don't resolve the file just yet, but move to the next file"
        echo " r - reset and repeat same file"
        echo " q - stop everything"
        while true ; do
                read -n 1 -p "Commit? [y/n/r/q] " res
                echo
                case $res in
                        q) exit 0                               ;; # bail
                        y) git update-index "$file"  ; return 0 ;; # resolve, next
                        n)                             return 0 ;; # next
                        r) cp -f "$conflict" "$file" ; return 1 ;; # cleanup, repeat
                esac
        done
        exit 1
}


#### make sure we are in a good state

while [ "${1:0:1}" = '-' ] ; do
        cmd=$1 ; shift
        case "$cmd" in
        -v)     be_verbose=1 ;;
        -d)     do_debug=1 ;;
        --am)   do_am_merge=1 ;;
        -s)     do_status_only=1 ;;
        -k)     do_gitk_only=1 ;;
        -l)
                get_unmerged_files
                exit 0
                ;;
        -h|--help)
                help 0
                ;;
        *)
                warn "invlid option $cmd"
                help 1
                ;;
        esac
done

if [ ! -z "$do_am_merge" ] ; then
        am_head=$(get_commit_id HEAD)
        am_patch=$(printf '%04d' $(cat .dotest/next))

else
        id_orig=$(get_commit_id ORIG_HEAD)
        id_merge=$(get_commit_id MERGE_HEAD)
        id_base=$(git merge-base $id_orig $id_merge)
fi
files=$(get_unmerged_files)

[ -z "$do_debug" ] || set -x
[ -z "$do_status_only" ] || ( dump_status ; exit 0 )
[ -z "$do_gitk_only" ] || ( run_gitk ; exit 0 )

for file in $files ; do

        vecho "Working on: $file"

        finished=false
        until $finished ; do

                if [ ! -z "$do_am_merge" ] ; then
                        # make a backup of this file
                        conflict_file=".am-merge.$am_head."$(echo -n "$file" | tr -c 'A-Za-z0-9_.-' '_')
                        [ -f "$conflict_file" ] || cp $file $conflict_file

                        vecho "Presenting: merged, ancestor"
                        vimdiff $file <(git-cat -r HEAD $file) \
                        -c ":0;g/$conflict_markers"
                        #-c ":0;:silent! :%foldopen!;g/$conflict_markers"
                else
                        # make a backup of this file
                        conflict_file=".conflict.$id_orig.$id_merge."$(echo -n "$file" | tr -c 'A-Za-z0-9_.-' '_')
                        [ -f "$conflict_file" ] || cp $file $conflict_file

                        vecho "Presenting: ancestor, new changes, edited"
                        vimdiff <(git-cat -r $id_base $file) <(git-cat -r $id_merge $file) $file \
                        -c ":0;g/$conflict_markers"
                fi

                if (grep -q "$conflict_markers"  "$file") ; then
                        echo
                        echo "WARNING: looks like the file still has merge markers and may not be resolved..."
                        grep -H -n "$conflict_markers" $file
                        echo
                fi

                vecho "Commit changes you just made?"

                if commit_repeat_prompt "$file" "$conflict_file" ; then
                        finished=true
                fi
        done
done
